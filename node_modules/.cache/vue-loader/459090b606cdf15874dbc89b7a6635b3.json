{"remainingRequest":"/Users/marcoseiza/LocalDocuments/3152/GraveyardShift/level-editor/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/marcoseiza/LocalDocuments/3152/GraveyardShift/level-editor/src/components/Dashboard.vue?vue&type=style&index=0&id=aae30ed8&scoped=true&lang=css&","dependencies":[{"path":"/Users/marcoseiza/LocalDocuments/3152/GraveyardShift/level-editor/src/components/Dashboard.vue","mtime":1616642493920},{"path":"/Users/marcoseiza/LocalDocuments/3152/GraveyardShift/level-editor/node_modules/css-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/marcoseiza/LocalDocuments/3152/GraveyardShift/level-editor/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":499162500000},{"path":"/Users/marcoseiza/LocalDocuments/3152/GraveyardShift/level-editor/node_modules/postcss-loader/src/index.js","mtime":499162500000},{"path":"/Users/marcoseiza/LocalDocuments/3152/GraveyardShift/level-editor/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/marcoseiza/LocalDocuments/3152/GraveyardShift/level-editor/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCi5zaXplV3JhcHBlciB7CiAgZGlzcGxheTogZmxleDsKICBhbGlnbi1pdGVtczogY2VudGVyOwogIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47CiAgbWFyZ2luLWxlZnQ6IGF1dG87CiAgbWFyZ2luLXJpZ2h0OiBhdXRvOwp9Cgouc2l6ZUlucHV0cyB7CiAgbWFyZ2luLXRvcDogMC41cmVtOwogIGRpc3BsYXk6IGZsZXg7Cn0KCi5pbnB1dCB7CiAgbWF4LXdpZHRoOiAycmVtOwogIG1hcmdpbjogMCAwLjVyZW07Cn0KCi5idXR0b24gewogIG1hcmdpbi10b3A6IDAuNXJlbTsKfQoKLnRvb2xzQW5kTWFwV3JhcHBlciB7CiAgZGlzcGxheTogZmxleDsKICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsKfQoKLm91dHB1dFdyYXBwZXIgewogIG1hcmdpbi10b3A6IDFyZW07Cn0KCi5pbnN0cnVjdGlvbnMgewogIGRpc3BsYXk6IGZsZXg7CiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjsKICBqdXN0aWZ5LWNvbnRlbnQ6IGxlZnQ7CiAgdGV4dC1hbGlnbjogbGVmdDsKfQoKLmluc3RydWN0aW9uc1RpdGxlIHsKICBtYXJnaW4tYm90dG9tOiAwOwogIG1hcmdpbi10b3A6IDJyZW07Cn0K"},{"version":3,"sources":["Dashboard.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmNA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"Dashboard.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div class=\"dashboard\">\n    <h1>Level Editor</h1>\n    <div class=\"sizeWrapper\">\n      <span>What size should the level be (in tiles, width x height)?</span>\n      <div class=\"sizeInputs\">\n        <input class=\"input\" v-model=\"cols\" /> x\n        <input class=\"input\" v-model=\"rows\" />\n      </div>\n      <button class=\"button\" @click=\"updateDimensions\">Create Map</button>\n    </div>\n    <div class=\"toolsAndMapWrapper\" v-if=\"dimensionsSet\">\n      <tool-bar @update-tile-placing=\"updateTilePlacing\" />\n      <level-map\n        :height=\"height\"\n        :width=\"width\"\n        :typeToPlace=\"typePlacing\"\n        @tile-changed=\"updateTiles\"\n      />\n    </div>\n    <div v-if=\"dimensionsSet\" class=\"outputWrapper\">\n      <span>Level Number:</span>\n      <input class=\"input\" v-model=\"levelNumber\" />\n      <button @click=\"writeJSON\">Output File</button>\n      <div class=\"instructions\">\n        <h3 class=\"instructionsTitle\">\n          Instructions For Downloading and Playing the Level\n        </h3>\n        <ol class=\"instructionsList\">\n          <li>\n            Set the level number as 1 + the current max level in the codebase.\n          </li>\n          <li>\n            After downloading, add the level to /core/assets/levels/\n          </li>\n          <li>\n            Set the maxLevels variable in GameplayController to this level\n            number.\n          </li>\n          <li>\n            Add an import for this new JSON file in /core/assets/assets.json\n          </li>\n          <li>\n            After all of this, the level should be playable!\n          </li>\n        </ol>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport LevelMap from \"@/components/LevelMap.vue\";\nimport ToolBar from \"@/components/ToolBar.vue\";\n\n// UPDATE THE VERSION NUMBER WHEN THE JSON CHANGES\n// TODO - convert old versions to new versions somehow\nconst versionNumber = \"1.0\";\n\nexport default {\n  components: { LevelMap, ToolBar },\n  data() {\n    return {\n      width: 0,\n      height: 0,\n      rows: \"\",\n      cols: \"\",\n      levelNumber: 0,\n      dimensionsSet: false,\n      typePlacing: \"floor\",\n      tiles: [],\n    };\n  },\n  methods: {\n    // update the board dimensions on button click\n    updateDimensions() {\n      this.width = Number(this.cols);\n      this.height = Number(this.rows);\n      this.dimensionsSet = true;\n    },\n    // when the tiles are updated in LevelMap, update them in Dashboard for JSON purposes\n    updateTiles(tiles) {\n      this.tiles = tiles;\n      console.log(this.tiles);\n    },\n    // update the tile being placed when a button is clicked on in ToolBar\n    updateTilePlacing(type) {\n      this.typePlacing = type;\n    },\n    // create the json based on the map and call the output method\n    writeJSON() {\n      // TODO - remove hardcoded values\n      let json = {};\n      json[\"version\"] = versionNumber;\n\n      let mutantSpawns = this.findObjects(\"mutant\");\n      let brickSpawns = this.findObjects(\"brick\");\n      let bombSpawns = this.findObjects(\"bomb\");\n      let itemSpawns = this.generateItemSpawns(brickSpawns, bombSpawns);\n\n      // set metadata\n      let metadata = {\n        width: this.width,\n        height: this.height,\n        \"player-spawn\": this.findPlayer(),\n        \"mutant-count\": mutantSpawns.length,\n        \"mutant-spawns\": mutantSpawns,\n        \"item-count\": brickSpawns.length + bombSpawns.length,\n        \"item-spawns\": itemSpawns,\n      };\n      json[\"metadata\"] = metadata;\n\n      // set layout\n      let layout = [];\n      for (let r = this.height - 1; r >= 0; r--) {\n        for (let c = 0; c < this.width; c++) {\n          if (this.tiles[r][c] === \"wall\") {\n            layout.push(1);\n          } else if (this.tiles[r][c] === \"glass\") {\n            layout.push(2);\n          } else if (this.tiles[r][c] === \"goal\") {\n            layout.push(4);\n          } else {\n            layout.push(0);\n          }\n        }\n      }\n      json[\"layout\"] = layout;\n      console.log(json);\n\n      this.outputJSONToFile(json);\n    },\n    // output json to a file with provided level number and automatically download it to the user's computer\n    outputJSONToFile(json) {\n      // code source: https://stackoverflow.com/questions/48611671/vue-js-write-json-object-to-local-file\n      const data = JSON.stringify(json);\n      const blob = new Blob([data], { type: \"text/plain\" });\n      const e = document.createEvent(\"MouseEvents\"),\n        a = document.createElement(\"a\");\n      a.download = \"level\" + this.levelNumber + \".json\";\n      a.href = window.URL.createObjectURL(blob);\n      a.dataset.downloadurl = [\"text/json\", a.download, a.href].join(\":\");\n      e.initEvent(\n        \"click\",\n        true,\n        false,\n        window,\n        0,\n        0,\n        0,\n        0,\n        0,\n        false,\n        false,\n        false,\n        false,\n        0,\n        null\n      );\n      a.dispatchEvent(e);\n    },\n    // returns the location of the player, or an empty array if not found\n    // TODO - should we require a player to exist\n    // TODO - added transforms to here and other methods to match json, maybe json file should be changed\n    findPlayer() {\n      for (let r = 0; r < this.height; r++) {\n        for (let c = 0; c < this.width; c++) {\n          if (this.tiles[r][c] === \"player\") {\n            return [c, this.height - r - 1];\n          }\n        }\n      }\n      return [];\n    },\n    // returns a 2d array representing all positions of objectType\n    // used to find mutants, bombs, bricks, etc.\n    findObjects(objectType) {\n      let objectList = [];\n      for (let r = 0; r < this.height; r++) {\n        for (let c = 0; c < this.width; c++) {\n          if (this.tiles[r][c] === objectType) {\n            objectList.push([c, this.height - r - 1]);\n          }\n        }\n      }\n      return objectList;\n    },\n    // returns the json representation of all the item types and their locations\n    generateItemSpawns(bricks, bombs) {\n      let itemSpawns = [];\n      bricks.forEach((b) => {\n        let item = {};\n        item.type = \"BRICK\";\n        item.position = b;\n        itemSpawns.push(item);\n      });\n\n      bombs.forEach((b) => {\n        let item = {};\n        item.type = \"BOMB\";\n        item.position = b;\n        itemSpawns.push(item);\n      });\n\n      return itemSpawns;\n    },\n  },\n};\n</script>\n\n<style scoped>\n.sizeWrapper {\n  display: flex;\n  align-items: center;\n  flex-direction: column;\n  margin-left: auto;\n  margin-right: auto;\n}\n\n.sizeInputs {\n  margin-top: 0.5rem;\n  display: flex;\n}\n\n.input {\n  max-width: 2rem;\n  margin: 0 0.5rem;\n}\n\n.button {\n  margin-top: 0.5rem;\n}\n\n.toolsAndMapWrapper {\n  display: flex;\n  justify-content: center;\n}\n\n.outputWrapper {\n  margin-top: 1rem;\n}\n\n.instructions {\n  display: flex;\n  flex-direction: column;\n  justify-content: left;\n  text-align: left;\n}\n\n.instructionsTitle {\n  margin-bottom: 0;\n  margin-top: 2rem;\n}\n</style>\n"]}]}